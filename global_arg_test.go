package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

type buildConstraintTest struct {
	Name          string
	Args          []string
	ExpectedLines []string
}

var buildConstraintTests = []buildConstraintTest{
	{
		Name: "single build constraint",
		Args: []string{"-buildconstraint", "integrationtest"},
		ExpectedLines: []string{
			"// Code generated by \"enumer %s\"; DO NOT EDIT.",
			"//go:build integrationtest",
			"",
			"package main",
		},
	},
	{
		Name: "or build constraint",
		Args: []string{"-buildconstraint", "unittest || integrationtest"},
		ExpectedLines: []string{
			"// Code generated by \"enumer %s\"; DO NOT EDIT.",
			"//go:build unittest || integrationtest",
			"",
			"package main",
		},
	},
	{
		Name: "multi build constraint",
		Args: []string{"-buildconstraint", "integrationtest", "-buildconstraint", "unittest"},
		ExpectedLines: []string{
			"// Code generated by \"enumer %s\"; DO NOT EDIT.",
			"//go:build integrationtest",
			"//go:build unittest",
			"",
			"package main",
		},
	},
	{
		Name: "single comment",
		Args: []string{"-comment", "Some long comment explaining what this enum is all about..."},
		ExpectedLines: []string{
			"// Code generated by \"enumer %s\"; DO NOT EDIT.",
			"",
			"// Some long comment explaining what this enum is all about...",
			"package main",
		},
	},
	{
		Name: "multi comment",
		Args: []string{"-comment", "Some long comment", "-comment", "explaining what", "-comment", "", "-comment", "    this enum is all about..."},
		ExpectedLines: []string{
			"// Code generated by \"enumer %s\"; DO NOT EDIT.",
			"",
			"// Some long commentexplaining what    this enum is all about...",
			"package main",
		},
	},
}

func TestGlobalArgs(t *testing.T) {
	const TypeName = "SnakeCaseValue"
	const InputFilename = "transform_snake.go"
	const TransformNameMethod = "SnakeCaseValue"

	dir, err := ioutil.TempDir("", "stringer")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(dir)

	// Create stringer in temporary directory.
	stringer := filepath.Join(dir, fmt.Sprintf("stringer%s", GOEXE))
	err = run("go", "build", "-o", stringer)
	if err != nil {
		t.Fatalf("building stringer: %s", err)
	}

	for _, test := range buildConstraintTests {
		stringSource := filepath.Join(dir, InputFilename)

		// combine arguments
		var args []string
		args = append(args, "-type", TypeName, "-output", stringSource, "-transform", TransformNameMethod)
		args = append(args, test.Args...)
		args = append(args, filepath.Join("testdata/"+InputFilename))

		// Run stringer in temporary directory.
		t.Logf("run: %s %v\n", stringer, args)
		err = run(stringer, args...)
		if err != nil {
			t.Fatal(err)
		}

		actual := loadResult(t, stringSource, len(test.ExpectedLines))

		if len(actual) != len(test.ExpectedLines) {
			t.Errorf("'%s': expected at least %d line in the output but found only %d",
				test.Name,
				len(test.ExpectedLines),
				len(actual),
			)
		}

		for idx := 0; idx < len(test.ExpectedLines); idx++ {
			expected := test.ExpectedLines[idx]

			// The first line is a special case as the contents is dynamic
			if idx == 0 {
				expected = fmt.Sprintf(expected, strings.Join(args, " "))
			}

			if actual[idx] != expected {
				t.Errorf("'%s': expected line %d \n\tto be  : %s\n\tbut was: %s",
					test.Name,
					idx,
					expected,
					actual[idx])
			}
		}
	}
}

func loadResult(t *testing.T, filename string, lineCount int) []string {
	fh, err := os.Open(filename)
	if err != nil {
		t.Fatal(err)
		return nil
	}
	defer fh.Close()

	lines := make([]string, 0)
	scanner := bufio.NewScanner(fh)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
		lineCount--
		if lineCount <= 0 {
			break
		}
	}

	return lines
}
